

// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
uniform mat4 ModelViewProjectionMatrix, NormalMatrix;
uniform vec3 lightPath;

varying vec3 vertPos;
varying vec3 vertNV;
varying vec3 vertCol;

vec3 inCol = vec3(0.0,0.9,0.9);
float shininess = 95.0;
vec3 ambient = vec3(0.2,0.2,0.2);
vec3 diffuse = vec3(0.6,0.6,0.6);
vec3 specular = vec3(0.8,0.8,0.8);

vec3 Light( vec3 eyeV, vec3 N ) {
      vec3  lightCol  = ambient;
      vec3  L         = normalize( -lightPath );
      float NdotL     = max( 0.0, dot( N, L ) );
      lightCol       += NdotL * diffuse;
      vec3  H         = normalize( eyeV + L );
      float NdotH     = max( 0.0, dot( N, H ) );
      float kSpecular = ( shininess + 2.0 ) * pow( NdotH, shininess ) / ( 2.0 * 3.14159265 );
      lightCol       += kSpecular * specular;
      return lightCol; 
}

void main() {
    vec3 modelNV  = mat3( NormalMatrix ) * normalize( normal );
      vertNV        = mat3( ModelViewProjectionMatrix ) * modelNV;
      vec4 modelPos = ModelViewProjectionMatrix * vec4( vertex, 1.0 );
      vec4 viewPos  = ModelViewProjectionMatrix * modelPos;
      vertPos       = viewPos.xyz / viewPos.w;
      vec3 eyeV     = normalize( -vertPos );
      vec3 normalV  = normalize( vertNV );
      vertCol       = inCol * Light( eyeV, normalV );
    gl_Position = ModelViewProjectionMatrix * vec4(vertex,1.0);
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

varying vec3 vertCol;

void main() {
    gl_FragColor = vec4(vertCol,1.0);
}`;